(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :
  typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :
  (global = global || self, factory(global.troika_three_utils = {}, global.THREE));
}(this, (function (exports, three) { 'use strict';

  /**
   * Regular expression for matching the `void main() {` opener line in GLSL.
   * @type {RegExp}
   */
  var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;

  /**
   * Recursively expands all `#include <xyz>` statements within string of shader code.
   * Copied from three's WebGLProgram#parseIncludes for external use.
   *
   * @param {string} source - The GLSL source code to evaluate
   * @return {string} The GLSL code with all includes expanded
   */
  function expandShaderIncludes( source ) {
    var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function replace(match, include) {
      var chunk = three.ShaderChunk[include];
      return chunk ? expandShaderIncludes(chunk) : match
    }
    return source.replace( pattern, replace )
  }

  // Local assign polyfill to avoid importing troika-core
  var assign = Object.assign || function(/*target, ...sources*/) {
    var arguments$1 = arguments;

    var target = arguments[0];
    for (var i = 1, len = arguments.length; i < len; i++) {
      var source = arguments$1[i];
      if (source) {
        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            target[prop] = source[prop];
          }
        }
      }
    }
    return target
  };


  var idCtr = 0;
  var epoch = Date.now();
  var CACHE = new WeakMap(); //threejs requires WeakMap internally so should be safe to assume support


  /**
   * A utility for creating a custom shader material derived from another material's
   * shaders. This allows you to inject custom shader logic and transforms into the
   * builtin ThreeJS materials without having to recreate them from scratch.
   *
   * @param {THREE.Material} baseMaterial - the original material to derive from
   *
   * @param {Object} options - How the base material should be modified.
   * @param {Object} options.defines - Custom `defines` for the material
   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`
   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can
   *        be accessed and manipulated via the resulting material's `uniforms` property, just like
   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.
   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into
   *        both shaders, and it will automatically be updated on each render frame with a number of
   *        elapsed milliseconds. The "zero" epoch time is not significant so don't rely on this as a
   *        true calendar time.
   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level
   *        definitions, above the `void main()` function.
   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex
   *        shader's `void main` function.
   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex
   *        shader's `void main` function.
   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,
   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with
   *        those attributes exposed by their normal names as read/write values.
   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level
   *        definitions, above the `void main()` function.
   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment
   *        shader's `void main` function.
   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment
   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes
   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you
   *        want those to apply to your changes use `fragmentColorTransform` instead.
   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`
   *        output value. Will be injected near the end of the `void main` function, but before any
   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the
   *        `fragmentMainOutro`.
   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function
   *        for performing custom rewrites of the full shader code. Useful if you need to do something
   *        special that's not covered by the other builtin options. This function will be executed before
   *        any other transforms are applied.
   *
   * @return {THREE.Material}
   *
   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,
   * which can be called to get a variant of the derived material for use in shadow casting. If the
   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`
   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to
   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These
   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look
   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance
   * scenarios, e.g. skipping antialiasing or expensive shader logic.
   */
  function createDerivedMaterial(baseMaterial, options) {
    // First check the cache to see if we've already derived from this baseMaterial using
    // this unique set of options, and if so just return a clone instead of a new subclass
    // which is faster and allows their shader program to be shared when rendering.
    var optionsHash = getOptionsHash(options);
    var cached = CACHE.get(baseMaterial);
    if (!cached) {
      cached = Object.create(null);
      CACHE.set(baseMaterial, cached);
    }
    if (cached[optionsHash]) {
      return cached[optionsHash].clone()
    }

    var id = ++idCtr;
    var privateDerivedShadersProp = "_derivedShaders" + id;
    var privateBeforeCompileProp = "_onBeforeCompile" + id;
    var distanceMaterialTpl, depthMaterialTpl;

    // Private onBeforeCompile handler that injects the modified shaders and uniforms when
    // the renderer switches to this material's program
    function onBeforeCompile(shaderInfo) {
      baseMaterial.onBeforeCompile.call(this, shaderInfo);

      // Upgrade the shaders, caching the result
      var ref = this[privateDerivedShadersProp] || (this[privateDerivedShadersProp] = {vertex: {}, fragment: {}});
      var vertex = ref.vertex;
      var fragment = ref.fragment;
      if (vertex.source !== shaderInfo.vertexShader || fragment.source !== shaderInfo.fragmentShader) {
        var upgraded = upgradeShaders(shaderInfo, options, id);
        vertex.source = shaderInfo.vertexShader;
        vertex.result = upgraded.vertexShader;
        fragment.source = shaderInfo.fragmentShader;
        fragment.result = upgraded.fragmentShader;
      }

      // Inject upgraded shaders and uniforms into the program
      shaderInfo.vertexShader = vertex.result;
      shaderInfo.fragmentShader = fragment.result;
      assign(shaderInfo.uniforms, this.uniforms);

      // Inject auto-updating time uniform if requested
      if (options.timeUniform) {
        shaderInfo.uniforms[options.timeUniform] = {
          get value() {return Date.now() - epoch}
        };
      }

      // Users can still add their own handlers on top of ours
      if (this[privateBeforeCompileProp]) {
        this[privateBeforeCompileProp](shaderInfo);
      }
    }

    function DerivedMaterial() {
      baseMaterial.constructor.apply(this, arguments);
      this._listeners = undefined; //don't inherit EventDispatcher listeners
    }
    DerivedMaterial.prototype = Object.create(baseMaterial, {
      constructor: {value: DerivedMaterial},
      isDerivedMaterial: {value: true},
      baseMaterial: {value: baseMaterial},

      onBeforeCompile: {
        get: function get() {
          return onBeforeCompile
        },
        set: function set(fn) {
          this[privateBeforeCompileProp] = fn;
        }
      },

      copy: {
        value: function (source) {
          baseMaterial.copy.call(this, source);
          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
            this.extensions = assign({}, source.extensions);
            this.defines = assign({}, source.defines);
            this.uniforms = three.UniformsUtils.clone(source.uniforms);
          }
          return this
        }
      },

      /**
       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
       * transformations and discarded fragments.
       */
      getDepthMaterial: {value: function() {
        var depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          if (!depthMaterialTpl) {
            depthMaterialTpl = createDerivedMaterial(
              baseMaterial.isDerivedMaterial
                ? baseMaterial.getDepthMaterial()
                : new three.MeshDepthMaterial({depthPacking: three.RGBADepthPacking}),
              options
            );
            depthMaterialTpl.defines.IS_DEPTH_MATERIAL = '';
          }
          depthMaterial = this._depthMaterial = depthMaterialTpl.clone();
          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
        }
        return depthMaterial
      }},

      /**
       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
       * transformations and discarded fragments.
       */
      getDistanceMaterial: {value: function() {
        var distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          if (!distanceMaterialTpl) {
            distanceMaterialTpl = createDerivedMaterial(
              baseMaterial.isDerivedMaterial
                ? baseMaterial.getDistanceMaterial()
                : new three.MeshDistanceMaterial(),
              options
            );
            distanceMaterialTpl.defines.IS_DISTANCE_MATERIAL = '';
          }
          distanceMaterial = this._distanceMaterial = distanceMaterialTpl.clone();
          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
        }
        return distanceMaterial
      }},

      dispose: {value: function value() {
        var ref = this;
        var _depthMaterial = ref._depthMaterial;
        var _distanceMaterial = ref._distanceMaterial;
        if (_depthMaterial) { _depthMaterial.dispose(); }
        if (_distanceMaterial) { _distanceMaterial.dispose(); }
        baseMaterial.dispose.call(this);
      }}
    });

    var material = new DerivedMaterial();
    material.copy(baseMaterial);

    // Merge uniforms, defines, and extensions
    material.uniforms = assign(three.UniformsUtils.clone(baseMaterial.uniforms || {}), options.uniforms);
    material.defines = assign({}, baseMaterial.defines, options.defines);
    material.defines.TROIKA_DERIVED_MATERIAL = id; //force a program change from the base material
    material.extensions = assign({}, baseMaterial.extensions, options.extensions);

    cached[optionsHash] = material;
    return material.clone() //return a clone so changes made to it don't affect the cached object
  }


  function upgradeShaders(ref, options, id) {
    var vertexShader = ref.vertexShader;
    var fragmentShader = ref.fragmentShader;

    var vertexDefs = options.vertexDefs;
    var vertexMainIntro = options.vertexMainIntro;
    var vertexMainOutro = options.vertexMainOutro;
    var vertexTransform = options.vertexTransform;
    var fragmentDefs = options.fragmentDefs;
    var fragmentMainIntro = options.fragmentMainIntro;
    var fragmentMainOutro = options.fragmentMainOutro;
    var fragmentColorTransform = options.fragmentColorTransform;
    var customRewriter = options.customRewriter;
    var timeUniform = options.timeUniform;

    vertexDefs = vertexDefs || '';
    vertexMainIntro = vertexMainIntro || '';
    vertexMainOutro = vertexMainOutro || '';
    fragmentDefs = fragmentDefs || '';
    fragmentMainIntro = fragmentMainIntro || '';
    fragmentMainOutro = fragmentMainOutro || '';

    // Expand includes if needed
    if (vertexTransform || customRewriter) {
      vertexShader = expandShaderIncludes(vertexShader);
    }
    if (fragmentColorTransform || customRewriter) {
      // We need to be able to find postprocessing chunks after include expansion in order to
      // put them after the fragmentColorTransform, so mark them with comments first. Even if
      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,
      // so we still mark them.
      fragmentShader = fragmentShader.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        '\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n'
      );
      fragmentShader = expandShaderIncludes(fragmentShader);
    }

    // Apply custom rewriter function
    if (customRewriter) {
      var res = customRewriter({vertexShader: vertexShader, fragmentShader: fragmentShader});
      vertexShader = res.vertexShader;
      fragmentShader = res.fragmentShader;
    }

    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract
    // those and re-insert them into the outro in the correct place:
    if (fragmentColorTransform) {
      var postChunks = [];
      fragmentShader = fragmentShader.replace(
        /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines
        function (match) {
          postChunks.push(match);
          return ''
        }
      );
      fragmentMainOutro = fragmentColorTransform + "\n" + (postChunks.join('\n')) + "\n" + fragmentMainOutro;
    }

    // Inject auto-updating time uniform if requested
    if (timeUniform) {
      var code = "\nuniform float " + timeUniform + ";\n";
      vertexDefs = code + vertexDefs;
      fragmentDefs = code + fragmentDefs;
    }

    // Inject a function for the vertexTransform and rename all usages of position/normal/uv
    if (vertexTransform) {
      vertexDefs = vertexDefs + "\nvec3 troika_position_" + id + ";\nvec3 troika_normal_" + id + ";\nvec2 troika_uv_" + id + ";\nvoid troikaVertexTransform" + id + "(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  " + vertexTransform + "\n}\n";
      vertexMainIntro = "\ntroika_position_" + id + " = vec3(position);\ntroika_normal_" + id + " = vec3(normal);\ntroika_uv_" + id + " = vec2(uv);\ntroikaVertexTransform" + id + "(troika_position_" + id + ", troika_normal_" + id + ", troika_uv_" + id + ");\n" + vertexMainIntro + "\n";
      vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, function (match, match1, index, fullStr) {
        return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : ("troika_" + match1 + "_" + id)
      });
    }

    // Inject defs and intro/outro snippets
    vertexShader = injectIntoShaderCode(vertexShader, id, vertexDefs, vertexMainIntro, vertexMainOutro);
    fragmentShader = injectIntoShaderCode(fragmentShader, id, fragmentDefs, fragmentMainIntro, fragmentMainOutro);

    return {
      vertexShader: vertexShader,
      fragmentShader: fragmentShader
    }
  }

  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
    if (intro || outro || defs) {
      shaderCode = shaderCode.replace(voidMainRegExp, ("\n" + defs + "\nvoid troikaOrigMain" + id + "() {")
      );
      shaderCode += "\nvoid main() {\n  " + intro + "\n  troikaOrigMain" + id + "();\n  " + outro + "\n}";
    }
    return shaderCode
  }

  function getOptionsHash(options) {
    return JSON.stringify(options, optionsJsonReplacer)
  }

  function optionsJsonReplacer(key, value) {
    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value
  }

  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders
  // TODO how can we keep this from getting stale?
  var MATERIAL_TYPES_TO_SHADERS = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'phong',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };

  /**
   * Given a Three.js `Material` instance, find the shaders/uniforms that will be
   * used to render that material.
   *
   * @param material - the Material instance
   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`
   */
  function getShadersForMaterial(material) {
    var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];
    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?
  }

  /**
   * Find all uniforms and their types within a shader code string.
   *
   * @param {string} shader - The shader code to parse
   * @return {object} mapping of uniform names to their glsl type
   */
  function getShaderUniformTypes(shader) {
    var uniformRE = /\buniform\s+(int|float|vec[234])\s+([A-Za-z_][\w]*)/g;
    var uniforms = Object.create(null);
    var match;
    while ((match = uniformRE.exec(shader)) !== null) {
      uniforms[match[2]] = match[1];
    }
    return uniforms
  }

  /**
   * @class ShaderFloatArray
   *
   * When writing a custom WebGL shader, sometimes you need to pass it an array of floating
   * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,
   * because:
   *
   *   - GLSL "array" uniforms can only be of a constant length.
   *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`
   *     extension is available.
   *
   * ShaderFloatArray is an array-like abstraction that encodes its floating point data into
   * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms
   * and GLSL code for you to put in your custom shader to query the float values by array index.
   *
   * This should generally only be used within a fragment shader, as some environments (e.g. iOS)
   * only allow texture lookups in fragment shaders.
   *
   * TODO:
   *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits
   *   - Use a float texture if the extension is available so we can skip the encoding process
   */
  var ShaderFloatArray = function ShaderFloatArray(name) {
    this.name = name;
    this.textureUniform = "dataTex_" + name;
    this.textureSizeUniform = "dataTexSize_" + name;
    this.multiplierUniform = "dataMultiplier_" + name;

    /**
     * @property dataSizeUniform - the name of the GLSL uniform that will hold the
     * length of the data array.
     * @type {string}
     */
    this.dataSizeUniform = "dataSize_" + name;

    /**
     * @property readFunction - the name of the GLSL function that should be called to
     * read data out of the array by index.
     * @type {string}
     */
    this.readFunction = "readData_" + name;

    this._raw = new Float32Array(0);
    this._texture = new three.DataTexture(new Uint8Array(0), 0, 1);
    this._length = 0;
    this._multiplier = 1;
  };

  var prototypeAccessors = { length: { configurable: true } };

  /**
   * @property length - the current length of the data array
   * @type {number}
   */
  prototypeAccessors.length.set = function (value) {
    if (value !== this._length) {
      // Find nearest power-of-2 that holds the new length
      var size = Math.pow(2, Math.ceil(Math.log2(value)));
      var raw = this._raw;
      if (size < raw.length) {
        this._raw = raw.subarray(0, size);
      }
      else if(size > raw.length) {
        this._raw = new Float32Array(size);
        this._raw.set(raw);
      }
      this._length = value;
    }
  };
  prototypeAccessors.length.get = function () {
    return this._length
  };

  /**
   * Add a value to the end of the data array
   * @param {number} value
   */
  ShaderFloatArray.prototype.push = function push (value) {
    return this.set(this.length++, value)
  };

  /**
   * Replace the existing data with that from a new array
   * @param {ArrayLike<number>} array
   */
  ShaderFloatArray.prototype.setArray = function setArray (array) {
    this.length = array.length;
    this._raw.set(array);
    this._needsRepack = true;
  };

  /**
   * Get the current value at index
   * @param {number} index
   * @return {number}
   */
  ShaderFloatArray.prototype.get = function get (index) {
    return this._raw[index]
  };

  ShaderFloatArray.prototype.set = function set (index, value) {
    if (index + 1 > this._length) {
      this.length = index + 1;
    }
    if (value !== this._raw[index]) {
      this._raw[index] = value;
      encodeFloatToFourInts(
        value / this._multiplier,
        this._texture.image.data,
        index * 4
      );
      this._needsMultCheck = true;
    }
  };

  /**
   * Make a copy of this ShaderFloatArray
   * @return {ShaderFloatArray}
   */
  ShaderFloatArray.prototype.clone = function clone () {
    var clone = new ShaderFloatArray(this.name);
    clone.setArray(this._raw);
    return clone
  };

  /**
   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or
   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.
   * @return {Object}
   */
  ShaderFloatArray.prototype.getShaderUniforms = function getShaderUniforms () {
      var obj;

    var me = this;
    return ( obj = {}, obj[this.textureUniform] = {get value() {
        me._sync();
        return me._texture
      }}, obj[this.textureSizeUniform] = {get value() {
        me._sync();
        return me._texture.image.width
      }}, obj[this.dataSizeUniform] = {get value() {
        me._sync();
        return me.length
      }}, obj[this.multiplierUniform] = {get value() {
        me._sync();
        return me._multiplier
      }}, obj )
  };

  /**
   * Retrieve the GLSL code that must be injected into the shader's definitions area to
   * enable reading from the data array. This exposes a function with a name matching
   * the {@link #readFunction} property, which other shader code can call to read values
   * from the array by their index.
   * @return {string}
   */
  ShaderFloatArray.prototype.getShaderHeaderCode = function getShaderHeaderCode () {
    var ref = this;
      var textureUniform = ref.textureUniform;
      var textureSizeUniform = ref.textureSizeUniform;
      var dataSizeUniform = ref.dataSizeUniform;
      var multiplierUniform = ref.multiplierUniform;
      var readFunction = ref.readFunction;
    return ("\nuniform sampler2D " + textureUniform + ";\nuniform float " + textureSizeUniform + ";\nuniform float " + dataSizeUniform + ";\nuniform float " + multiplierUniform + ";\n\nfloat " + readFunction + "(float index) {\n  vec2 texUV = vec2((index + 0.5) / " + textureSizeUniform + ", 0.5);\n  vec4 pixel = texture2D(" + textureUniform + ", texUV);\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * " + multiplierUniform + ";\n}\n")
  };

  /**
   * @private Synchronize any pending changes to the underlying DataTexture
   */
  ShaderFloatArray.prototype._sync = function _sync () {
    var tex = this._texture;
    var raw = this._raw;
    var needsRepack = this._needsRepack;

    // If the size of the raw array changed, resize the texture to match
    if (raw.length !== tex.image.width) {
      tex.image = {
        data: new Uint8Array(raw.length * 4),
        width: raw.length,
        height: 1
      };
      needsRepack = true;
    }

    // If the values changed, check the multiplier. This should be a value by which
    // all the values are divided to constrain them to the [0,1] range required by
    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the
    // maximum value for greatest accuracy.
    if (needsRepack || this._needsMultCheck) {
      var maxVal = this._raw.reduce(function (a, b) { return Math.max(a, b); }, 0);
      var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));
      if (mult !== this._multiplier) {
        this._multiplier = mult;
        needsRepack = true;
      }
      tex.needsUpdate = true;
      this._needsMultCheck = false;
    }

    // If things changed in a way we need to repack, do so
    if (needsRepack) {
      for (var i = 0, len = raw.length, mult$1 = this._multiplier; i < len; i++) {
        encodeFloatToFourInts(raw[i] / mult$1, tex.image.data, i * 4);
      }
      this._needsRepack = false;
    }
  };

  Object.defineProperties( ShaderFloatArray.prototype, prototypeAccessors );



  /**
   * Encode a floating point number into a set of four 8-bit integers.
   * Also see the companion decoder function #decodeFloatFromFourInts.
   *
   * This is adapted to JavaScript from the basic approach at
   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
   * but writes out integers in the range 0-255 instead of floats in the range 0-1
   * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.
   *
   * Some precision will necessarily be lost during the encoding and decoding process.
   * Testing shows that the maximum precision error is ~1.18e-10 which should be good
   * enough for most cases.
   *
   * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]
   *        otherwise the results will be incorrect.
   * @param {Array|Uint8Array} array - an array into which the four ints should be written
   * @param {Number} startIndex - index in the output array at which to start writing the ints
   * @return {Array|Uint8Array}
   */
  function encodeFloatToFourInts(value, array, startIndex) {
    // This is adapted to JS from the basic approach at
    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
    // but writes to a Uint8Array instead of floats. Input values must be in
    // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10
    var enc0 = 255 * value;
    var enc1 = 255 * (enc0 % 1);
    var enc2 = 255 * (enc1 % 1);
    var enc3 = 255 * (enc2 % 1);

    enc0 = enc0 & 255;
    enc1 = enc1 & 255;
    enc2 = enc2 & 255;
    enc3 = Math.round(enc3) & 255;

    array[startIndex] = enc0;
    array[startIndex + 1] = enc1;
    array[startIndex + 2] = enc2;
    array[startIndex + 3] = enc3;
    return array
  }

  /*
  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,
  divided into a reasonable number of height segments.
  */

  var vertexDefs = "\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n";

  var vertexTransform = "\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n";

  var fragmentDefs = "\nuniform vec3 dashing;\nvarying float bezierT;\n";

  var fragmentMainIntro = "\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n";

  // Debugging: separate color for each of the 6 sides:
  // const fragmentColorTransform = `
  // float sideNum = floor(vUV.x * 6.0);
  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :
  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :
  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :
  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :
  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :
  //   vec3(1.0, 0.0, 1.0);
  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);
  // `



  function createBezierMeshMaterial(baseMaterial) {
    return createDerivedMaterial(
      baseMaterial,
      {
        uniforms: {
          pointA: {value: new three.Vector3()},
          controlA: {value: new three.Vector3()},
          controlB: {value: new three.Vector3()},
          pointB: {value: new three.Vector3()},
          radius: {value: 0.01},
          dashing: {value: new three.Vector3()} //on, off, offset
        },
        vertexDefs: vertexDefs,
        vertexTransform: vertexTransform,
        fragmentDefs: fragmentDefs,
        fragmentMainIntro: fragmentMainIntro
      }
    )
  }

  var geometry = null;

  var defaultBaseMaterial = new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});


  /**
   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done
   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four
   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`
   * automatically.
   *
   * The cubiz bezier path is determined by its four `Vector3` properties:
   * - `pointA`
   * - `controlA`
   * - `controlB`
   * - `pointB`
   *
   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.
   *
   * You can also give the tube a dashed appearance with two properties:
   *
   * - `dashArray` - an array of two numbers, defining the length of "on" and "off" parts of
   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length
   *   used as input to the cubic bezier function, not its visible length.)
   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.
   *
   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on
   * thicker tubes.
   *
   * TODO: proper geometry bounding sphere and raycasting
   * TODO: allow control of the geometry's segment counts
   */
  var BezierMesh = /*@__PURE__*/(function (Mesh) {
    function BezierMesh() {
      Mesh.call(
        this, BezierMesh.getGeometry(),
        defaultBaseMaterial
      );

      this.pointA = new three.Vector3();
      this.controlA = new three.Vector3();
      this.controlB = new three.Vector3();
      this.pointB = new three.Vector3();
      this.radius = 0.01;
      this.dashArray = new three.Vector2();
      this.dashOffset = 0;

      // TODO - disabling frustum culling until I figure out how to customize the
      //  geometry's bounding sphere that gets used
      this.frustumCulled = false;
    }

    if ( Mesh ) BezierMesh.__proto__ = Mesh;
    BezierMesh.prototype = Object.create( Mesh && Mesh.prototype );
    BezierMesh.prototype.constructor = BezierMesh;

    var prototypeAccessors = { material: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };

    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
    BezierMesh.getGeometry = function getGeometry () {
      return geometry || (geometry =
        new three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)
      )
    };

    prototypeAccessors.material.get = function () {
      var derivedMaterial = this._derivedMaterial;
      var baseMaterial = this._baseMaterial || defaultBaseMaterial;
      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
        if (derivedMaterial) {
          derivedMaterial.dispose();
        }
        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);
        // dispose the derived material when its base material is disposed:
        baseMaterial.addEventListener('dispose', function onDispose() {
          baseMaterial.removeEventListener('dispose', onDispose);
          derivedMaterial.dispose();
        });
      }
      return derivedMaterial
    };
    prototypeAccessors.material.set = function (baseMaterial) {
      this._baseMaterial = baseMaterial;
    };

    // Create and update material for shadows upon request:
    prototypeAccessors.customDepthMaterial.get = function () {
      return this.material.getDepthMaterial()
    };
    prototypeAccessors.customDistanceMaterial.get = function () {
      return this.material.getDistanceMaterial()
    };

    BezierMesh.prototype.onBeforeRender = function onBeforeRender (shaderInfo) {
      var ref = this.material;
      var uniforms = ref.uniforms;
      var ref$1 = this;
      var pointA = ref$1.pointA;
      var controlA = ref$1.controlA;
      var controlB = ref$1.controlB;
      var pointB = ref$1.pointB;
      var radius = ref$1.radius;
      var dashArray = ref$1.dashArray;
      var dashOffset = ref$1.dashOffset;
      uniforms.pointA.value.copy(pointA);
      uniforms.controlA.value.copy(controlA);
      uniforms.controlB.value.copy(controlB);
      uniforms.pointB.value.copy(pointB);
      uniforms.radius.value = radius;
      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);
    };

    BezierMesh.prototype.raycast = function raycast (raycaster, intersects) {
      // TODO - just fail for now
    };

    Object.defineProperties( BezierMesh.prototype, prototypeAccessors );

    return BezierMesh;
  }(three.Mesh));

  exports.BezierMesh = BezierMesh;
  exports.ShaderFloatArray = ShaderFloatArray;
  exports.createDerivedMaterial = createDerivedMaterial;
  exports.expandShaderIncludes = expandShaderIncludes;
  exports.getShaderUniformTypes = getShaderUniformTypes;
  exports.getShadersForMaterial = getShadersForMaterial;
  exports.voidMainRegExp = voidMainRegExp;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
